"""Classes, models and clients to interact with myID's API.

- Identity provides core digital ID functionality.
- Pydantic models and dataclasses define API request and response objects.
- Clients, each with differing authentication mechanisms, implement API endpoints:
    - UnauthenticatedClient
    - AssuranceClient
    - CredentialClient
    - ExtensionClient

Run module doctests:
    uv run python -m doctest --verbose --option ELLIPSIS myid.py
"""

import base64
import random
import time
from dataclasses import dataclass
from typing import Annotated, Optional
from uuid import uuid4

import httpx
import jwt
import meatie_httpx
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import (
    BestAvailableEncryption,
    Encoding,
    pkcs7,
    pkcs12,
)
from cryptography.x509.oid import NameOID
from meatie import api_ref, body, endpoint
from pydantic import BaseModel


@dataclass
class CertificateSigningRequest:
    """Base64 DER-encoded PKCS#10 certificate request.

    From http://pki.ato.gov.au/policy/ATO%20PKI%20Certificate%20Policy%20-%20myID%20User%20Credential.pdf:
        6.1.3 Public Key Delivery to Certificate Issuer
        The Subscriberâ€™s public key is provided to the CA in a PKCS#10 certificate request
        file signed with the corresponding private key.
    """

    p10: str


class CertificateResponse(BaseModel):
    id: int
    p7: str
    p10: str
    credentialToken: str
    links: list[dict[str, str]]


class Identity:
    """Represents a digital identity at the core of myID.

    An Identity associates an RSA key pair with a signed myID User Certificate.

    Class methods implement utilities for interacting with the myID system, as well
    as helpers to export or import an Identity.

    Instantiating an Identity generates a key:

    >>> email = "john.citizen@gmail.com"
    >>> identity = Identity(email)
    >>> identity.key
    <cryptography.hazmat...rsa.RSAPrivateKey object at 0x...>

    Create a certificate signing request *after* your email address has been verified
    by myID. A proof of identity (POI) process ID is generated by myID during verification.

    >>> proof_of_identity_process_id = "abcd1234-dead-beef-face-abcd12345678"  # from myID
    >>> identity.create_certificate_signing_request(proof_of_identity_process_id)
    CertificateSigningRequest(p10='...')

    Process the certificate response returned by myID:

    >>> # from myID
    >>> certificate_response = CertificateResponse(
    ...     id=123,
    ...     p7="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",
    ...     p10="...",
    ...     credentialToken="...",
    ...     links=[]
    ... )
    >>> identity.process_certificate_response(certificate_response)
    >>> identity.certificate
    <Certificate(subject=<Name(C=AU,O=mygovid.gov.au,CN=poi id,2.5.4.46=...)>, ...)>

    With a certificate, authorization grant and client authentication assertions
    can be created:

    >>> identity.create_authorization_grant()
    'eyJhb...'
    >>> identity.create_client_authentication()
    'eyJhb...'

    Extract the Identity's POI identifier from its certificate:

    >>> identity.get_proof_of_identity_process_id()
    'poi id'

    Export an identity to a file, encrypted with a password:

        with open(f"{email}.p12", "wb") as file:
            file.write(identity.export(b"secret password"))

    Import an exported Identity:

        with open(f"{email}.p12", "rb") as file:
            identity = Identity.from_export(file.read(), b"secret password")
    """

    def __init__(
        self,
        email: str,
        key: Optional[rsa.RSAPrivateKey] = None,
        certificate: Optional[x509.Certificate] = None,
    ):
        """Instantiates Identity associated with email address.

        A new key is generated by default.
        """
        self.email = email
        if key is None:
            self.key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        else:
            self.key = key
        self.certificate = certificate

    def create_certificate_signing_request(
        self, proof_of_identity_process_id: str
    ) -> CertificateSigningRequest:
        """Returns certificate signing request signed by identity's key.

        Complies with myID user certificate policy located here:
        http://pki.ato.gov.au/policy/ATO%20PKI%20Certificate%20Policy%20-%20myID%20User%20Credential.pdf
        In fact, we are *more* compliant than the official myID app.
        """
        csr = (
            x509.CertificateSigningRequestBuilder()
            # 7.1.4 Name forms
            # The Subject Name component is based on the Subscriberâ€™s POI ID and generated UUID and
            # defined as {CN = <POI ID>, dnQualifier = <UUID>, O = mygovid.gov.au, C = AU}.
            .subject_name(
                x509.Name(
                    [
                        # myID app devs read "CN = <POI ID>" too literally and set CN to "poi id" ðŸ˜‚.
                        # We follow policy and set it to the POI identifier.
                        x509.NameAttribute(
                            NameOID.COMMON_NAME, proof_of_identity_process_id
                        ),
                        x509.NameAttribute(NameOID.DN_QUALIFIER, str(uuid4())),
                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "mygovid.gov.au"),
                        x509.NameAttribute(NameOID.COUNTRY_NAME, "AU"),
                    ]
                )
            )
            .add_extension(
                # https://oidref.com/1.2.36.1.333.1 says this OID should identify ABN.
                extval=x509.UnrecognizedExtension(
                    x509.ObjectIdentifier("1.2.36.1.333.1"), b"\x16\x0emygovid.gov.au"
                ),
                critical=False,
            )
            .sign(self.key, hashes.SHA512())
        )
        return CertificateSigningRequest(
            p10=base64.standard_b64encode(csr.public_bytes(Encoding.DER)).decode()
        )

    def process_certificate_response(self, certificate_response: CertificateResponse):
        """Assigns myID user certificate extracted from certificate response."""
        certificates = pkcs7.load_der_pkcs7_certificates(
            base64.standard_b64decode(certificate_response.p7)
        )
        # User certificate is first in the chain.
        self.certificate = certificates[0]

    def create_authorization_grant(self) -> str:
        """Returns authorization grant as JWT assertion signed using identity's key.

        See RFC 7523: https://www.rfc-editor.org/rfc/rfc7523#section-2.1
        """
        assert self.certificate
        return jwt.encode(
            payload={
                "jti": str(uuid4()),
                "sub": self.email,
                "nbf": int(time.time()),
                "exp": int(time.time()) + 3600,
                "iss": f"https://ausidapp.gov.au/{self.certificate.serial_number}",
                "aud": "https://myGovId.gov.au/connect/token",
            },
            key=self.key,
            algorithm="RS256",
            headers={
                "kid": self.certificate.fingerprint(hashes.SHA1()).hex().upper(),
                # Base64 DER-encoded certificate
                "x5c": [
                    base64.standard_b64encode(
                        self.certificate.public_bytes(Encoding.DER)
                    ).decode()
                ],
            },
        )

    def create_client_authentication(self) -> str:
        """Returns client authentication as JWT assertion signed using identity's key.

        See RFC 7523: https://www.rfc-editor.org/rfc/rfc7523#section-2.2
        """
        assert self.certificate
        return jwt.encode(
            payload={
                "jti": str(uuid4()),
                "sub": f"https://ausidapp.gov.au/{self.certificate.serial_number}",
                "nbf": int(time.time()),
                "exp": int(time.time()) + 3600,
                "iss": f"https://ausidapp.gov.au/{self.certificate.serial_number}",
                "aud": "https://myGovId.gov.au/connect/token",
            },
            key=self.key,
            algorithm="RS256",
            headers={
                "kid": self.certificate.fingerprint(hashes.SHA1()).hex().upper(),
                # Base64 DER-encoded certificate
                "x5c": [
                    base64.standard_b64encode(
                        self.certificate.public_bytes(Encoding.DER)
                    ).decode()
                ],
            },
        )

    def get_proof_of_identity_process_id(self) -> str:
        """Returns proof of identity process ID from certificate."""
        assert self.certificate
        attributes = self.certificate.subject.get_attributes_for_oid(
            NameOID.COMMON_NAME
        )
        assert isinstance(attributes[0].value, str)
        return attributes[0].value

    def export(self, password: bytes) -> bytes:
        """Returns identity serialized to PKCS#12 binary format, encrypted using password."""
        assert self.certificate
        return pkcs12.serialize_key_and_certificates(
            self.email.encode(),
            self.key,
            self.certificate,
            None,
            BestAvailableEncryption(password),
        )

    @staticmethod
    def from_export(data: bytes, password: bytes) -> "Identity":
        """Returns Identity instantiated from deserialized PKCS#12 export."""
        p12 = pkcs12.load_pkcs12(data, password)
        assert p12.cert
        assert p12.cert.friendly_name
        email = p12.cert.friendly_name.decode()
        assert isinstance(p12.key, rsa.RSAPrivateKey)
        key = p12.key
        certificate = p12.cert.certificate
        return Identity(email, key, certificate)


class TermsAndConditions(BaseModel):
    url: str
    version: str


@dataclass
class Link:
    rel: str
    method: str
    href: str
    authentication: str


class ProofOfIdentityProcess(BaseModel):
    status: str
    strength: str
    acceptedTermsAndConditionsVersion: str
    processId: str
    links: list[Link]


class EmailVerificationTask(BaseModel):
    id: int
    status: str
    eta: int
    remainingRetryCount: int
    processId: str
    links: list[dict]


@dataclass
class EmailVerificationBody:
    emailAddress: str
    verificationCode: str


class EmailVerificationResult(BaseModel):
    verificationCodeResult: str
    poiAssuranceToken: str
    processId: str
    links: list[dict]


# Static headers required by every request.
static_headers = {
    "X-AuditCallingAppName": "myID",
    "X-AuditCallingAppVersion": "3.1.0.2",
    # not strictly required
    # "User-Agent": "myID/0 CFNetwork/1220.1 Darwin/20.3.0",
}
# Base URL for all httpx clients.
base_url = "https://mygovid.gov.au/api/v1"


async def add_request_id(request):
    """Adds unique request ID header to request."""
    request.headers["X-AuditRequestId"] = random.randbytes(16).hex()


async def add_session_id(request):
    """Adds unique session ID header to request."""
    request.headers["X-AuditSessionId"] = random.randbytes(16).hex()


async def get_terms_and_conditions_json(response: httpx.Response) -> dict:
    """Returns nested terms and conditions object."""
    return response.json()["termsAndConditions"]


class UnauthenticatedClient(meatie_httpx.AsyncClient):
    """myID client for unauthenticated endpoints.

    >>> import asyncio
    >>> async def test():
    ...     async with UnauthenticatedClient() as client:
    ...         terms_and_conditions = await client.get_terms_and_conditions()
    ...         print(repr(terms_and_conditions))
    ...
    ...         proof_of_identity_process = await client.initiate_proof_of_identity_process(terms_and_conditions.version)
    ...         print(repr(proof_of_identity_process))
    >>> asyncio.run(test())
    TermsAndConditions(url='https://www.myid.gov.au/app_terms', version='1.0.0.0')
    ProofOfIdentityProcess(status='', strength='', acceptedTermsAndConditionsVersion='1.0.0.0', processId='...', links=[Link(...), Link(...)])
    """

    def __init__(self):
        """Initiates HTTP client with static and dynamic headers."""
        super().__init__(
            httpx.AsyncClient(
                headers=static_headers,
                event_hooks={"request": [add_request_id, add_session_id]},
                base_url=base_url,
            )
        )

    @endpoint("/termsAndConditions", body(get_terms_and_conditions_json))
    async def get_terms_and_conditions(self) -> TermsAndConditions:
        """Returns terms and conditions response."""

    @endpoint("/poi", method="POST")
    async def initiate_proof_of_identity_process(
        self,
        # Transform version into JSON body.
        version: Annotated[
            str, api_ref("body", fmt=lambda version: {"acceptedVersion": version})
        ],
    ) -> ProofOfIdentityProcess:
        """Returns proof of identity process details.

        `version` specifies accepted terms and conditions version.

        Reference `processId` field in subsequent steps.
        """

    @endpoint("/poi/{process_id}/documents/emails", method="POST")
    async def initiate_email_verification_task(
        self,
        process_id: str,
        # Transform into JSON body.
        email: Annotated[
            str, api_ref("body", fmt=lambda email: {"emailAddress": email})
        ],
    ) -> EmailVerificationTask:
        """Returns email verification task details for `email`.

        Reference `id` field in subsequent steps.
        """

    @endpoint(
        "/poi/{process_id}/tasks/{task_id}/emailVerificationResponse",
        method="POST",
    )
    async def complete_email_verification_task(
        self, process_id: str, task_id: int, body: EmailVerificationBody
    ) -> EmailVerificationResult:
        """Submits verification code and returns email verification result details.

        Verification is successful if `verificationCodeResult` field is `"Verified"`.
        """


class CertificateSigningTask(BaseModel):
    id: int
    status: str
    eta: int
    links: list[dict]


class AssuranceClient(meatie_httpx.AsyncClient):
    """myID client for endpoints authenticated with "assurance" token.

    This client's endpoints are used to obtain a signed certificate.

    Initialise client with token obtained after verifying email:
    `EmailVerificationResult.poiAssuranceToken`.
    """

    def __init__(self, token: str):
        """Initialise HTTP client with JWT bearer token.

        X-AuditSessionId header is set to JWT's ID (jti).
        """
        super().__init__(
            httpx.AsyncClient(
                headers=static_headers
                | {
                    "Authorization": f"Bearer {token}",
                    # session id header matches jwt's id
                    "X-AuditSessionId": (
                        jwt.decode(token, options={"verify_signature": False})["jti"]
                    ),
                },
                # Automatically follow /credentials/tasks/{task_id} redirect.
                follow_redirects=True,
                event_hooks={"request": [add_request_id]},
                base_url=base_url,
            )
        )

    @endpoint("/credentials/x509s", method="POST")
    async def initiate_certificate_signing_task(
        self, body: CertificateSigningRequest
    ) -> CertificateSigningTask:
        """Submits certificate signing request.

        Returns certificate signing task details (reference `id` field in subsequent
        steps.)
        """

    @endpoint("/credentials/tasks/{task_id}")
    async def get_signed_certificate(self, task_id: int) -> CertificateResponse:
        """Returns signed certificate response.

        follow_redirects=True allows redirect to /credentials/x509s/issueStatements/...
        """


@dataclass
class DateOfBirth:
    year: int
    month: int
    day: int


class PersonalDetailsBody(BaseModel):
    givenName: str
    familyName: str
    dateOfBirth: DateOfBirth


class PersonalDetailsDocument(BaseModel):
    documentId: int
    givenName: str
    familyName: str
    dateOfBirth: DateOfBirth
    processId: str
    links: list[Link]


class CredentialClient(meatie_httpx.AsyncClient):
    """myID client for endpoints authenticated with "credential" token.

    This client's endpoint is used to provide initial personal details for
    basic myID identity strength.
    """

    def __init__(self, token: str):
        """Initialise HTTP client with JSON Web Token found in certificate response:
        `CertificateResponse.credentialToken`.

        X-AuditSessionId header is set to JWT's ID (jti).
        """
        super().__init__(
            httpx.AsyncClient(
                headers=static_headers
                | {
                    "Authorization": f"Bearer {token}",
                    "X-AuditSessionId": (
                        jwt.decode(token, options={"verify_signature": False})["jti"]
                    ),
                },
                event_hooks={"request": [add_request_id]},
                base_url=base_url,
            )
        )

    @endpoint("/poi/{process_id}/documents/personalDetailsDocuments")
    async def post_personal_details(
        self, process_id: str, body: PersonalDetailsBody
    ) -> PersonalDetailsDocument:
        """Submits personal details for verification to achieve Basic identity strength.

        Personal details match those previously submitted for an identity tied to
        the same email address.

        Basic identity strength must be achieved before using ExtensionClient.
        """


class OidcAuth(httpx.Auth):
    """Implements myID's OpenID Connect authentication flow."""

    requires_response_body = True

    def __init__(self, identity: Identity):
        """Initialise with Identity to generate signed JSON Web Tokens."""
        self.identity = identity
        self.token = None
        self.jti = None

    def auth_flow(self, request):
        """Performs OpenID Connect flow.

        Subsequent requests use access token (self.token) obtained during first request.

        Sets Authorization header to bearer access token.
        Sets X-AuditSessionId header to JWT's ID (jti).
        """
        if self.token is None:
            assertion = self.identity.create_authorization_grant()
            client_assertion = self.identity.create_client_authentication()
            response = yield httpx.Request(
                "POST",
                "https://mygovid.gov.au/core/connect/token",
                data={
                    "grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
                    "assertion": assertion,
                    "client_assertion": client_assertion,
                    "client_assertion_type": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
                    "scope": "openid credential_info email profile",
                },
            )
            self.token = response.json()["access_token"]
            self.jti = jwt.decode(self.token, options={"verify_signature": False})[
                "jti"
            ]
        assert self.token
        assert self.jti
        request.headers["Authorization"] = f"Bearer {self.token}"
        request.headers["X-AuditSessionId"] = self.jti
        yield request


class Device(BaseModel):
    appVersion: str
    createdDate: str
    formFactor: str
    isPushNotificationEnabled: bool
    lastExAuthnDate: str
    lastUpdatedDate: str
    name: str
    osVersion: str
    runtime: str
    runtimeVersion: str
    platform: str
    status: str
    version: int
    links: list[Link]
    notificationProvider: str

    def get_device_id(self) -> int:
        """Returns device ID parsed from links."""
        for link in self.links:
            if link.rel == "self" and link.method == "get":
                # >>> href = "/api/v2/identities/31399999/devices/26899999"
                # >>> href.split("/")[-1]
                # '26899999'
                return int(link.href.split("/")[-1])


class DevicesResponse(BaseModel):
    meta: dict
    items: list[Device]
    links: list[Link]


class EventAdditionalData(BaseModel):
    referenceCode: str
    validateReferenceCode: bool


class Event(BaseModel):
    eventId: int
    correlationId: str
    createdDate: str
    status: str
    expiryDate: str
    eventType: str
    links: list[Link]
    additionalData: EventAdditionalData


class ExtensionClient(meatie_httpx.AsyncClient):
    """myID client for endpoints authenticated with "extension" token.

    This client implements identity, device and (authentication) event endpoints.
    """

    def __init__(self, identity: Identity):
        """Initialise HTTP client with required OidcAuth parameters."""
        super().__init__(
            httpx.AsyncClient(
                auth=OidcAuth(identity),
                headers=static_headers,
                event_hooks={"request": [add_request_id]},
                base_url=base_url,
            )
        )

    @endpoint("/poi/{process_id}")
    async def get_proof_of_identity_process(
        self, process_id: str
    ) -> ProofOfIdentityProcess:
        """Returns proof of identity details.

        From `ProofOfIdentityProcess.links` we can pivot to an identity.
        """

    async def get_identity_id(self, process_id: str) -> int:
        """Returns identity ID parsed from `ProofOfIdentityProcess` links."""
        proof_of_identity_process = await self.get_proof_of_identity_process(process_id)
        for link in proof_of_identity_process.links:
            if link.href.startswith("/api/v1/identities/"):
                # >>> href = "/api/v1/identities/31329999/variationOptions"
                # >>> href.split("/")
                # ['', 'api', 'v1', 'identities', '31329999', 'variationOptions']
                return int(link.href.split("/")[4])

    @endpoint("/identities/{identity_id}/devices")
    async def get_devices(self, identity_id: int) -> DevicesResponse:
        """Returns details of devices associated with identity."""

    @endpoint("/identities/{identity_id}/devices/{device_id}/eventqueue", method="GET")
    async def check_event_queue(
        self, identity_id: int, device_id: int, action: str = "visit"
    ) -> Event:
        """Returns event or raises `meatie.ParseResponseError` exception.

        Poll this endpoint, wrapped in a try/except clause event is returned.

        The server returns a 404 status if there is no event, causing Meatie to
        fail to parse the (lack of) response.
        """

    # TODO: accept/reject event
    # @endpoint("/identities/{identity_id}/events")
    # async def post_event():
    #     pass

    # TODO: delete event
    # @endpoint("/identities/{identity_id}/devices/{device_id}/eventqueue/events/{event_id}")
    # async def delete_event():
    #     pass
